<!DOCTYPE html>
 <html>
    <head>		
		<title>Solar System | Demo</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		
		<!-- Owl Carousel -->
		<link type="text/css" rel="stylesheet" href="css/owl.carousel.css" />
		<link type="text/css" rel="stylesheet" href="css/owl.theme.default.css" />
				<!-- Custom stlylesheet -->
		<link type="text/css" rel="stylesheet" href="css/style.css" />

		<style>
		body { margin: 0; }
		canvas { width: 100%; height: 100% }
		#info {
				position: absolute;
				top: 0px;
				width: 100%;
				color: #ffffff;
				padding: 5px;
				font-family:Monospace;
				font-size:13px;
				text-align:right;
			}
	  </style>

	  			<!-- jQuery Plugins -->
	<script type="text/javascript" src="js/jquery.min.js"></script>
	<script type="text/javascript" src="js/bootstrap.min.js"></script>
	<script type="text/javascript" src="js/owl.carousel.min.js"></script>
	<script type="text/javascript" src="js/jquery.magnific-popup.js"></script>
	<script type="text/javascript" src="js/main.js"></script>
	      <script src="js/three.min.js"></script>
		  <script src="js/OrbitControls.js"></script>
		  <script src="js/GLTFLoader.js"></script>
		  <script src="js/AnimationMixer.js"></script>
		  <script src="js/stats.min.js"></script>
		  <script src="js/CSS2DRenderer.js"></script>
		  <script src="js/libs/dat.gui.min.js"></script>
		  
  </head>
    <body>
	<div id="info">
	</div>
	<script>		
	
 	// Load 3D Scene
	var scene = new THREE.Scene(); 
	scene2 = new THREE.Scene();
	var Stats;
	var innerw,height;
	var stars=[];
	var guic, controlConfig= {
	freezState: false,
	revolveSpeed: 24
	};


	// For orbit
	var marker, spline;
	var matrix = new THREE.Matrix4();
	var up = new THREE.Vector3( 0, 1, 0 );
	var axis = new THREE.Vector3( );

	// Planet Orbit Variable Declaration
	var mercpath,venpath,earthpath,moonpath,marspath,juppath,satpath,urapath,neppath;

	var planet_pos=[];
	var planobj=[];
	var pathobj=[];
	// the getPoint starting variable - !important - You get me ;)
	var mt=vet=eat=mat=jupt=satt=urat=nept = 0;
	// Ellipse class, which extends the virtual base class Curve
	function Ellipse( xRadius, yRadius ) {
	THREE.Curve.call( this );
	// add radius as a property
	this.xRadius = xRadius;
	this.yRadius = yRadius;
	}

	Ellipse.prototype = Object.create( THREE.Curve.prototype );
	Ellipse.prototype.constructor = Ellipse;

	// define the getPoint function for the subClass
	Ellipse.prototype.getPoint = function ( t ) {

		var radians = 2 * Math.PI * t;

		return new THREE.Vector3( this.xRadius * Math.cos( radians ),
								0,
								this.yRadius * Math.sin( radians ) );

	};



 	// Load Camera Perspective
	var camera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 1, 20000 );
	camera.position.set( 10, 30, 100 );
	
	// RayCaster 
	raycaster = new THREE.Raycaster();
	mouse = new THREE.Vector2();


	// Load a Renderer
	var renderer = new THREE.WebGLRenderer({antialias: true});
	renderer.setClearColor( 0x000000 );
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.setSize(window.innerWidth, window.innerHeight);
	innerw=window.innerWidth;
	height=window.innerHeight;
	document.body.appendChild(renderer.domElement);

 	// Load the Orbitcontroller
	var controls = new THREE.OrbitControls( camera, renderer.domElement ); 
	controls.minDistance=10;
	controls.maxDistance=500;
 	// Load Light
	var ambientLight = new THREE.AmbientLight( 0xffffff );
	scene.add( ambientLight );


	var directionalLight = new THREE.DirectionalLight( 0xffffff );
	directionalLight.position.set( 0, 1, 1 ).normalize();
	scene.add( directionalLight );	
		


	// Stars
	function addSphere(){
		// The loop will move from z position of -1000 to z position 1000, adding a random particle at each position. 
		for ( var z= -1000; z < 1000; z+=20 ) {
		// Make a sphere (exactly the same as before). 
		var geometry   = new THREE.SphereGeometry(0.5, 32, 32)
		var starmat = new THREE.MeshBasicMaterial( {color: 0xffffff} );
		var sphere = new THREE.Mesh(geometry, starmat)
		sphere.position.x= Math.random()*innerw-Math.random()*innerw*2;
		sphere.position.y=Math.random()*height-Math.random()*height*2;
		// Then set the z position to where it is in the loop (distance of camera)
		sphere.position.z = z;	
		// scale it up a bit
		sphere.scale.x = sphere.scale.y = 1;
		//add the sphere to the scene
		scene.add( sphere );
			//finally push it to the stars array 
			stars.push(sphere); 
		}
	}
	function animateStars() { 
				
				// loop through each star
				for(var i=0; i<stars.length; i++) {
					star = stars[i]; 
					// and move it forward dependent on the mouseY position. 
					star.position.z +=  i/10;
					// if the particle is too close move it to the back
					if(star.position.z>2000) star.position.z-=3000; 
					
				}
			
	}

	
	

    // params
    var pathSegments = 128;
    var tubeRadius = 0.03;
    var radiusSegments = 3;
    var closed = true;
	

	var planet_id=[]

    // material
    var material = new THREE.MeshStandardMaterial( {
        color: 'white', 
    } );
	
	var mesh;
	
    // mercury orbit mesh
	mercpath = new Ellipse( 15, 10 );
    var mercgeometry = new THREE.TubeBufferGeometry( mercpath, pathSegments, tubeRadius, radiusSegments, closed );
	mesh = new THREE.Mesh( mercgeometry, material );
	scene.add( mesh );
	pathobj.push(mesh);
	
	// venus orbit mesh
	venpath = new Ellipse(22,15);
    var venusgeometry = new THREE.TubeBufferGeometry( venpath, pathSegments, tubeRadius, radiusSegments, closed );
	mesh = new THREE.Mesh( venusgeometry, material );
	scene.add( mesh );
	pathobj.push(mesh);
	// Earth Orbit
	earthpath = new Ellipse( 28, 22 );
    var earthgeometry = new THREE.TubeBufferGeometry( earthpath, pathSegments, tubeRadius, radiusSegments, closed );
	mesh = new THREE.Mesh( earthgeometry, material );
	scene.add( mesh );
	pathobj.push(mesh);
	// Moon
	moonpath = new Ellipse( 5, 3 );
    var moongeometry = new THREE.TubeBufferGeometry( moonpath, pathSegments, 0.0001, radiusSegments, closed );
	mesh = new THREE.Mesh( moongeometry, material );
	scene.add( mesh );
	pathobj.push(mesh);
	// Mars Orbit
	marspath = new Ellipse( 35, 28 );
    var marsgeometry = new THREE.TubeBufferGeometry( marspath, pathSegments, tubeRadius, radiusSegments, closed );
	mesh = new THREE.Mesh( marsgeometry, material );
	scene.add( mesh );
	pathobj.push(mesh);
	// Jupiter Orbit
	juppath = new Ellipse( 46, 34 );
    var jupgeometry = new THREE.TubeBufferGeometry( juppath, pathSegments, tubeRadius, radiusSegments, closed );
	mesh = new THREE.Mesh( jupgeometry, material );
	scene.add( mesh );
	pathobj.push(mesh);
	// Saturn Orbit
	satpath = new Ellipse( 57, 42 );
    var satgeometry = new THREE.TubeBufferGeometry( satpath, pathSegments, tubeRadius, radiusSegments, closed );
	mesh = new THREE.Mesh( satgeometry, material );
	scene.add( mesh );
	pathobj.push(mesh);
	// Uranus Orbit
	urapath = new Ellipse( 69, 49 );
    var urageometry = new THREE.TubeBufferGeometry( urapath, pathSegments, tubeRadius, radiusSegments, closed );
	mesh = new THREE.Mesh( urageometry, material );
	scene.add( mesh );
	pathobj.push(mesh);
	// Neptune Orbit
	neppath = new Ellipse( 79, 59 );
    var nepgeometry = new THREE.TubeBufferGeometry( neppath, pathSegments, tubeRadius, radiusSegments, closed );
	mesh = new THREE.Mesh( nepgeometry, material );
	scene.add( mesh );
	pathobj.push(mesh);
	
 	// glTf 2.0 Loader
	// var loader = new THREE.GLTFLoader();
	// Planets variables;
	var sun,mercury,venus,earth,moon,mars,jupiter,saturn,uranus,neptune;	

	var moonorbit;		

	/*
	 * PLANETS
	*/
	let planets = {sun, mercury, venus, earth, mars, jupiter, saturn, uranus, neptune};

	const loader = new THREE.TextureLoader();

	// const scene = new THREE.Scene();
	const geometry = new THREE.SphereGeometry(1, 48, 32);

	//sun
	const sunTexture = loader.load("texture/sun.jpg");
	const sunMaterial = new THREE.MeshStandardMaterial({ map: sunTexture });
	const sunGroup = new THREE.Group();
	const sunMesh = new THREE.Mesh(geometry, sunMaterial);
	sun = createPlanet(scene, sunMesh, sunGroup, 8);

	//mercury
	const mercuryTexture = loader.load("texture/mercury.jpg");
	const mercuryMaterial = new THREE.MeshStandardMaterial({ map: mercuryTexture });
	const mercuryGroup = new THREE.Group();
	const mercuryMesh = new THREE.Mesh(geometry, mercuryMaterial);
	mercury = createPlanet(scene, mercuryMesh, mercuryGroup, 0.8);
	planet_id.push(mercury.uuid);
	console.log(mercury.uuid);

	//venus
	const venusTexture = loader.load("texture/venus.jpg");
	const venusMaterial = new THREE.MeshStandardMaterial({ map: venusTexture });
	const venusGroup = new THREE.Group();
	const venusMesh = new THREE.Mesh(geometry, venusMaterial);
	venus = createPlanet(scene, venusMesh, venusGroup, 0.9);
	planet_id.push(venus.uuid);
	console.log(venus.uuid);

	//earth
	const earthTexture = loader.load("texture/earth.jpg");
	const earthMaterial = new THREE.MeshStandardMaterial({ map: earthTexture});
	const earthGroup = new THREE.Group();
	const earthMesh = new THREE.Mesh(geometry, earthMaterial);
	earth = createPlanet(scene, earthMesh, earthGroup, 1);
	planet_id.push(earth.uuid);

	//mars 
	const marsTexture = loader.load("texture/mars.jpg"); 
	const marsMaterial = new THREE.MeshStandardMaterial({ map: marsTexture });
	const marsGroup = new THREE.Group();
	const marsMesh = new THREE.Mesh(geometry, marsMaterial);
	mars = createPlanet(scene, marsMesh, marsGroup, 0.8);
	planet_id.push(mars.uuid);

	//jupiter
	const jupiterTexture = loader.load("texture/jupiter.jpg");
	const jupiterMaterial = new THREE.MeshStandardMaterial({ map: jupiterTexture });
	const jupiterGroup = new THREE.Group();
	const jupiterMesh = new THREE.Mesh(geometry, jupiterMaterial);
	jupiter = createPlanet(scene, jupiterMesh, jupiterGroup, 3.5);

	planet_id.push(jupiter.uuid);
		
	//saturn
	const saturnTexture = loader.load("texture/saturn.jpg");
	const saturnMaterial = new THREE.MeshStandardMaterial({ map: saturnTexture });
	const saturnGroup = new THREE.Group();
	const saturnMesh = new THREE.Mesh(geometry, saturnMaterial);

		// Saturns ring
		const innerRadius = 4;
		const outerRadius = 5.5;
		const thetaSegments = 60;
		const saturnBelt = new THREE.RingBufferGeometry(
			innerRadius, outerRadius, thetaSegments);
		const ringTexture = loader.load("texture/saturn_ring.png");
		const beltmat = new THREE.MeshStandardMaterial({
			side: THREE.DoubleSide, map: ringTexture
		});
		
		const beltmesh = new THREE.Mesh(saturnBelt, beltmat);
		beltmesh.rotation.set(5,0,0);

		// beltmesh.position.set(70, 0, 0);
		saturnGroup.add(beltmesh);

	saturn = createPlanet(scene, saturnMesh, saturnGroup, 2.9);
	planet_id.push(saturn.uuid);

	//uranus
	const uranusTexture = loader.load("texture/uranus.jpg");
	const uranusMaterial = new THREE.MeshStandardMaterial({ map: uranusTexture });
	const uranusGroup = new THREE.Group();
	const uranusMesh = new THREE.Mesh(geometry, uranusMaterial);
	uranus = createPlanet(scene, uranusMesh, uranusGroup, 1.7);
	planet_id.push(uranus.uuid);

	//neptunus
	const neptuneTexture = loader.load("texture/neptune.jpg");
	const neptuneMaterial = new THREE.MeshStandardMaterial({ map: neptuneTexture });
	const neptuneGroup = new THREE.Group();
	const neptuneMesh = new THREE.Mesh(geometry, neptuneMaterial);
	neptune = createPlanet(scene, neptuneMesh, neptuneGroup, 1.65);
	planet_id.push(neptune.uuid);


	function createPlanet(scene, mesh, group, scale) {
		mesh.scale.setScalar(scale);
		group.add(mesh);
		
		scene.add(group);
		planobj.push(group);
		
		return group;

	}



	// FPS stats
	stats = new Stats();
	document.body.appendChild( stats.dom );
	window.addEventListener( 'resize', onWindowResize, false );


	document.addEventListener( 'mouseclick', onDocumentMouseClick, false );
	document.addEventListener( 'mousedown', onDocumentMouseDown, false );
	document.addEventListener( 'touchstart', onDocumentTouchStart, false );

	guic = new dat.GUI( { width: 350 } );


	// Controls
	var controlGUI = guic.addFolder( "Controls" );
	//controlGUI.add(controlConfig.freezState,'Freeze State').listen();

	controlGUI.add( controlConfig, 'freezState' )
	
	controlGUI.add( controlConfig, 'revolveSpeed', 1, 24 ).onChange( function() 
	{
// 		sunLight.shadow.camera.near = shadowConfig.shadowCameraNear;
// 		sunLight.shadow.camera.updateProjectionMatrix();
// 		shadowCameraHelper.update();

	});



	function onWindowResize( event ) 
	{
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize( window.innerWidth, window.innerHeight );
	//controls.handleResize();
	}
	
	function onDocumentTouchStart( event ) {

	event.preventDefault();

	event.clientX = event.touches[0].clientX;
	event.clientY = event.touches[0].clientY;
	onDocumentMouseDown( event );
	onDocumentMouseClick( event );
	}

function onDocumentMouseDown( event ) {

	event.preventDefault();

	mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
	mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

	raycaster.setFromCamera( mouse, camera );

	 var intersects = raycaster.intersectObjects( pathobj );

	if ( intersects.length > 0 ) {
// 	var pt = intersects[0].getPoint( mt );

	
	}

}
		
		
	function onDocumentMouseClick( event ) {
		event.preventDefault();

		mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
		mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

		raycaster.setFromCamera( mouse, camera );
		
		var intersects = raycaster.intersectObjects( scene.children , false );
		
		if(intersects.length > 0) {
			var pt = intersects[0].getPoint( mt );
			console.log(intersects[0].uuid);
			console.log(pt);
			
			
			if(planet_id.some(id => id === intersects[0].uuid))
			{
				if(!controlConfig.freezState)
					controlConfig.freezState = true;
				
				stats.update();
			}
			
		}
	}
		
	
	function sunLight(scene) {
	    const color = 0xFFFFFF;
	    const intensity = 0.05;
	    const sunLight = new THREE.PointLight(color, intensity);
	    sunLight.position.set(0, 0, 0);

	    scene.add(sunLight)

	    this.update = function () {
		// do something
	    }

	    //gui.addColor(new ColorGUIHelper(light, 'color'), 'value').name('color');
	    //gui.add(light, 'intensity', 0.1, 2, 0.01);
	}
		
	function animate() 
	{
	requestAnimationFrame( animate );
	renderer.render( scene, camera );
	//if (!guic.freezState) return;
	animateStars();
	// TO freeze Planet State
	
// 	sunLight( scene );

	if(!controlConfig.freezState)
		revolvePlanet();
	console.log(controlConfig.revolveSpeed);
	stats.update();
	}


	function revolvePlanet(){
		if (mercury)
		{ 	//mercury.rotation.y+=0.05;
			var pt = mercpath.getPoint( mt );
			var tangent = mercpath.getTangent( mt ).normalize();
			mercury.position.set(pt.x,pt.y,pt.z);
			planet_pos.push(mercury.position.set(pt.x,pt.y,pt.z));
			// calculate the axis to rotate around
			axis.crossVectors( up, tangent ).normalize();
			// calcluate the angle between the up vector and the tangent
			var radians = Math.acos( up.dot( tangent ) );
			mt = (mt >= 1) ? 0 : mt += (0.005/controlConfig.revolveSpeed);
		}
		if (venus) 
		{	
			//venus.rotation.y+=0.04;
			var pt = venpath.getPoint( vet );
			var tangent = venpath.getTangent( vet ).normalize();
			venus.position.set(pt.x,pt.y,pt.z);
			planet_pos.push(venus.position.set(pt.x,pt.y,pt.z));
			// calculate the axis to rotate around
			axis.crossVectors( up, tangent ).normalize();
			// calcluate the angle between the up vector and the tangent
			var radians = Math.acos( up.dot( tangent ) );
			vet = (vet >= 1) ? 0 : vet += 0.001/controlConfig.revolveSpeed;
		}
		if (earth)
		{ 	earth.rotation.y+=0.02;
			var pt = earthpath.getPoint( eat );
			var tangent = earthpath.getTangent( eat ).normalize();
			earth.position.set(pt.x,pt.y,pt.z);
		 	planet_pos.push(earth.position.set(pt.x,pt.y,pt.z));
			// calculate the axis to rotate around
			axis.crossVectors( up, tangent ).normalize();
			// calcluate the angle between the up vector and the tangent
			var radians = Math.acos( up.dot( tangent ) );	
			eat = (eat >= 1) ? 0 : eat += 0.0003/controlConfig.revolveSpeed;
		}
		if (moon)
		{ 	moon.rotation.y+=0.02;
			var pt = earthpath.getPoint( eat );
			var tangent = earthpath.getTangent( eat ).normalize();
			moon.position.set(pt.x+2,pt.y+2,pt.z);
			// calculate the axis to rotate around
			axis.crossVectors( up, tangent ).normalize();
			// calcluate the angle between the up vector and the tangent
			var radians = Math.acos( up.dot( tangent ) );	
			eat = (eat >= 1) ? 0 : eat += 0.0003/controlConfig.revolveSpeed;
		}
		if (mars) 
		{	//mars.rotation.z+=0.02;
			var pt = marspath.getPoint( mat );
			var tangent = marspath.getTangent( mat );
			mars.position.set(pt.x,pt.y,pt.z);
			planet_pos.push(mars.position.set(pt.x,pt.y,pt.z));
			// calculate the axis to rotate around
			axis.crossVectors( up, tangent ).normalize();
			// calcluate the angle between the up vector and the tangent
			var radians = Math.acos( up.dot( tangent ) );
			mat = (mat >= 1) ? 0 : mat += 0.0001/controlConfig.revolveSpeed;
		}
		if (jupiter) 
		{	jupiter.rotation.y+=0.004;
			var pt = juppath.getPoint( jupt );
			var tangent = juppath.getTangent( jupt ).normalize();
			jupiter.position.set(pt.x,pt.y,pt.z);
		 	planet_pos.push(jupiter.position.set(pt.x,pt.y,pt.z));
			// calculate the axis to rotate around
			axis.crossVectors( up, tangent ).normalize();
			// calcluate the angle between the up vector and the tangent
			var radians = Math.acos( up.dot( tangent ) );
			jupt = (jupt >= 1) ? 0 : jupt += 0.00006/controlConfig.revolveSpeed;
		}
		if (saturn) 
		{	saturn.rotation.y+=0.009;
			var pt = satpath.getPoint( satt );
			var tangent = satpath.getTangent( satt ).normalize();
			saturn.position.set(pt.x,pt.y,pt.z);
			// calculate the axis to rotate around
			axis.crossVectors( up, tangent ).normalize();
			// calcluate the angle between the up vector and the tangent
			var radians = Math.acos( up.dot( tangent ) );
			satt = (satt >= 1) ? 0 : satt += 0.00003/controlConfig.revolveSpeed;
		}
		if (uranus) 
		{	uranus.rotation.y+=0.0004;
			var pt = urapath.getPoint( urat );
			var tangent = urapath.getTangent( urat ).normalize();
			uranus.position.set(pt.x,pt.y,pt.z);
		 	planet_pos.push(uranus.position.set(pt.x,pt.y,pt.z));
			// calculate the axis to rotate around
			axis.crossVectors( up, tangent ).normalize();
			// calcluate the angle between the up vector and the tangent
			var radians = Math.acos( up.dot( tangent ) );
			urat = (urat >= 1) ? 0 : urat += 0.000009/controlConfig.revolveSpeed;
		}
		if (neptune) 
		{	neptune.rotation.y+=0.0004;
			var pt = neppath.getPoint( nept );
			var tangent = neppath.getTangent( nept ).normalize();
			neptune.position.set(pt.x,pt.y,pt.z);
		 	planet_pos.push(neptune.position.set(pt.x,pt.y,pt.z));
			// calculate the axis to rotate around
			axis.crossVectors( up, tangent ).normalize();
			// calcluate the angle between the up vector and the tangent
			var radians = Math.acos( up.dot( tangent ) );
			nept = (nept >= 1) ? 0 : nept += 0.0000009/controlConfig.revolveSpeed;
		}
	}
	addSphere();
	animate();
			
</script>	
</body>
</html>
